<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Agente IA — Conversación</title>
    <link rel="stylesheet" href="/static/style.css">
  </head>
  <body>
    <header class="topbar">
      <div class="brand">Agente IA</div>
      <div class="controls">
        <select id="modelSelect"></select>
        <button id="changeModelBtn">Cambiar modelo</button>
      </div>
    </header>

    <main class="container">
      <!-- Zona de mensajes: ocupa todo el alto del contenedor (excepto el footer) con scroll propio -->
      <div id="chatLog" class="chat-log" aria-live="polite"></div>
    </main>

    <!-- Footer fijo en la parte inferior con el composer -->
    <footer class="footer">
      <div class="composer">
        <textarea id="prompt" placeholder="Escribe tu prompt aquí..." rows="3"></textarea>
        <div class="actions">
          <button id="sendBtn" class="primary">Enviar</button>
          <button id="clearBtn">Limpiar</button>
        </div>
      </div>
    </footer>

    <script>
    async function fetchModels(){
      const sel = document.getElementById('modelSelect');
      sel.innerHTML = '<option>Cargando...</option>';
      try{
        const res = await fetch('/api/models');
        const data = await res.json();
        sel.innerHTML = '';
        (data.models || []).forEach(m => {
          const o = document.createElement('option'); o.value = m; o.textContent = m; sel.appendChild(o);
        });
      }catch(e){
        sel.innerHTML = '<option>Error al listar</option>';
      }
    }

    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function mdStrongToHtml(text){
      // simple replacement of **bold** to <strong>
      return text.replace(/\*\*(.*?)\*\*/g, (_, m) => `<strong>${escapeHtml(m)}</strong>`);
    }

    function isPipeTable(text){
      if(!text) return false;
      const lines = text.split('\n').map(l=>l.trim());
      // find first line that starts with |
      const firstIdx = lines.findIndex(l => l.startsWith('|'));
      if(firstIdx === -1) return false;
      // require at least header and separator
      if(lines.length <= firstIdx + 1) return false;
      const sep = lines[firstIdx+1];
      // separator like |---|---|
      if(/^\|?\s*:?[-\s:|]+\s*\|?$/.test(sep)) return true;
      return false;
    }

    function renderPipeTable(text){
      const lines = text.split('\n');
      // find first pipe line
      let start = 0;
      while(start < lines.length && !lines[start].trim().startsWith('|')) start++;
      if(start >= lines.length) return null;
      // collect table lines starting at start until a non-pipe line
      const tableLines = [];
      for(let i=start;i<lines.length;i++){
        const l = lines[i];
        if(l.trim().startsWith('|')) tableLines.push(l.trim()); else break;
      }
      if(tableLines.length < 2) return null;

      // parse header and separator
      const headerLine = tableLines[0];
      const sepLine = tableLines[1];
      const headers = headerLine.split('|').slice(1,-1).map(h => h.trim());
      // build table element
      const table = document.createElement('table');
      table.className = 'pipe-table';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      headers.forEach(h => {
        const th = document.createElement('th');
        th.innerHTML = escapeHtml(h);
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for(let i=2;i<tableLines.length;i++){
        const cols = tableLines[i].split('|').slice(1,-1).map(c => c.trim());
        const tr = document.createElement('tr');
        cols.forEach(c => {
          const td = document.createElement('td');
          // convert **bold** inside cells
          const html = mdStrongToHtml(c);
          td.innerHTML = html;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      return table;
    }

    function renderTextWithTables(text){
      const lines = text.split('\n');
      const nodes = [];
      let buffer = [];
      const isSepLine = (l) => /^\|?\s*[:\-\s|]+\s*\|?$/.test(l.trim());

      for(let i=0;i<lines.length;){
        const line = lines[i];
        if(line.trim().startsWith('|') && i+1 < lines.length && isSepLine(lines[i+1])){
          // flush buffer
          if(buffer.length){
            const p = document.createElement('div');
            const txt = buffer.join('\n');
            p.innerHTML = mdStrongToHtml(escapeHtml(txt)).replace(/\n/g,'<br>');
            nodes.push(p);
            buffer = [];
          }

          // collect table lines
          const tableLines = [];
          tableLines.push(lines[i]);
          tableLines.push(lines[i+1]);
          i += 2;
          while(i < lines.length && lines[i].trim().startsWith('|')){
            tableLines.push(lines[i]);
            i++;
          }

          // build table
          const headerCols = tableLines[0].split('|').slice(1,-1).map(s=>s.trim());
          const table = document.createElement('table');
          table.className = 'pipe-table';
          const thead = document.createElement('thead');
          const trh = document.createElement('tr');
          headerCols.forEach(h=>{ const th = document.createElement('th'); th.innerHTML = escapeHtml(h); trh.appendChild(th); });
          thead.appendChild(trh); table.appendChild(thead);
          const tbody = document.createElement('tbody');
          for(let r=2;r<tableLines.length;r++){
            const cols = tableLines[r].split('|').slice(1,-1).map(s=>s.trim());
            const tr = document.createElement('tr');
            cols.forEach(c=>{ const td = document.createElement('td'); td.innerHTML = mdStrongToHtml(c); tr.appendChild(td); });
            tbody.appendChild(tr);
          }
          table.appendChild(tbody);
          nodes.push(table);
        } else {
          buffer.push(line);
          i++;
        }
      }
      if(buffer.length){
        const p = document.createElement('div');
        const txt = buffer.join('\n');
        p.innerHTML = mdStrongToHtml(escapeHtml(txt)).replace(/\n/g,'<br>');
        nodes.push(p);
      }
      return nodes;
    }

    function isCodeLike(text){
      // kept for possible fallback but not used by default heuristics
      if(!text) return false;
      const lines = text.split('\n');
      if(lines.length > 1) return true;
      if(/\b(ps|top|ls|df|du|grep|awk|sed)\b/.test(text)) return true;
      if(/\|\s*-+\s*\|/.test(text)) return true;
      return false;
    }

    function appendMessage(role, text, displayAs){
      const log = document.getElementById('chatLog');
      const el = document.createElement('div');
      el.className = 'msg ' + role;
      const roleEl = document.createElement('div');
      roleEl.className = 'role';
      roleEl.textContent = role;
      const bodyEl = document.createElement('div');
      bodyEl.className = 'text';

      // Render as code only when server explicitly requests it or when role is 'tool'.
      const shouldRenderAsCode = displayAs === 'code' || role === 'tool';

      // If text contains a pipe table, render text and tables preserving surrounding text
      if(isPipeTable(text)){
        const nodes = renderTextWithTables(text);
        if(nodes && nodes.length){
          nodes.forEach(n => bodyEl.appendChild(n));
        } else {
          bodyEl.innerHTML = escapeHtml(text).replace(/\n/g,'<br>');
        }
      } else if(shouldRenderAsCode){
        const pre = document.createElement('pre');
        pre.className = 'code-block';
        pre.innerHTML = escapeHtml(text);
        bodyEl.appendChild(pre);
      } else {
        bodyEl.innerHTML = escapeHtml(text).replace(/\n/g,'<br>');
      }

      el.appendChild(roleEl);
      el.appendChild(bodyEl);
      log.appendChild(el);
      log.scrollTop = log.scrollHeight;
    }

    document.addEventListener('DOMContentLoaded', ()=>{
      fetchModels();
      document.getElementById('sendBtn').onclick = async ()=>{
        const prompt = document.getElementById('prompt').value.trim();
        if(!prompt) return;
        appendMessage('user', prompt);
        document.getElementById('prompt').value = '';
        appendMessage('assistant','...');
        try{
          const res = await fetch('/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({prompt})});
          const data = await res.json();
          // Re-renderizar todo el historial devuelto por el servidor (salta el system)
          const log = document.getElementById('chatLog');
          log.innerHTML = '';
          (data.messages || []).forEach(m => {
            if(m.role && m.role !== 'system') appendMessage(m.role, m.content || (m.text||''), m.display_as);
          });
        }catch(e){
          appendMessage('assistant','Error al contactar con servidor');
        }
      };

      document.getElementById('changeModelBtn').onclick = async ()=>{
        const sel = document.getElementById('modelSelect');
        const model = sel.value;
        if(!model) return alert('Selecciona un modelo');
        try{
          const res = await fetch('/api/model',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({model})});
          const data = await res.json();
          alert('Modelo cambiado a: '+data.model);
        }catch(e){
          alert('Error al cambiar modelo');
        }
      };

      document.getElementById('clearBtn').onclick = ()=>{ document.getElementById('chatLog').innerHTML=''; };
    });
    </script>
  </body>
</html>
